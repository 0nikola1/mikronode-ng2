<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Index</title>
    
    
    
    
    
    <meta property="og:title" content=""/>
    <meta property="og:type" content="website"/>
    <meta property="og:image" content=""/>
    
    <meta property="og:url" content=""/>
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <script src="scripts/jquery.min.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/bootstrap.min.css">
    <link type="text/css" rel="stylesheet" href="styles/jaguar.css">
    
    
    <script>
    var config = {"monospaceLinks":true,"cleverLinks":true,"default":{"outputSourceFiles":true},"applicationName":"MikroNode","disqus":"","googleAnalytics":"","openGraph":{"title":"","type":"website","image":"","site_name":"","url":""},"meta":{"title":"","description":"","keyword":""},"linenums":false};
    </script>
    

    
</head>
<body>
<div id="wrap" class="clearfix">
    
<div class="navigation">
    <h3 class="applicationName"><a href="index.html">MikroNode</a></h3>

    <div class="search">
        <input id="search" type="text" class="form-control input-sm" placeholder="Search Documentations">
    </div>
    <ul class="list">
    
        <li class="item" data-name="mikronode.Channel">
            <span class="title">
                <a href="mikronode.Channel.html">mikronode.Channel</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="mikronode.Channel#clearEvents"><a href="mikronode.Channel.html#clearEvents">clearEvents</a></li>
            
                <li data-name="mikronode.Channel#closed"><a href="mikronode.Channel.html#closed">closed</a></li>
            
                <li data-name="mikronode.Channel#closeOnDone"><a href="mikronode.Channel.html#closeOnDone">closeOnDone</a></li>
            
                <li data-name="mikronode.Channel#closing"><a href="mikronode.Channel.html#closing">closing</a></li>
            
                <li data-name="mikronode.Channel#connection"><a href="mikronode.Channel.html#connection">connection</a></li>
            
                <li data-name="mikronode.Channel#id"><a href="mikronode.Channel.html#id">id</a></li>
            
                <li data-name="mikronode.Channel#lastCommand"><a href="mikronode.Channel.html#lastCommand">lastCommand</a></li>
            
                <li data-name="mikronode.Channel#running"><a href="mikronode.Channel.html#running">running</a></li>
            
                <li data-name="mikronode.Channel#saveBuffer"><a href="mikronode.Channel.html#saveBuffer">saveBuffer</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            <span class="subtitle">Typedefs</span>
            
                <li data-name="mikronode.Channel.writeCallback"><a href="mikronode.Channel.html#.writeCallback">writeCallback</a></li>
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="mikronode.Channel#close"><a href="mikronode.Channel.html#close">close</a></li>
            
                <li data-name="mikronode.Channel#finalize"><a href="mikronode.Channel.html#finalize">finalize</a></li>
            
                <li data-name="mikronode.Channel#write"><a href="mikronode.Channel.html#write">write</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            <span class="subtitle">Events</span>
            
                <li data-name="mikronode.Channel#event:close"><a href="mikronode.Channel.html#event:event:close">event:close</a></li>
            
                <li data-name="mikronode.Channel#event:done"><a href="mikronode.Channel.html#event:event:done">event:done</a></li>
            
                <li data-name="mikronode.Channel#event:error"><a href="mikronode.Channel.html#event:event:error">event:error</a></li>
            
                <li data-name="mikronode.Channel#event:timeout"><a href="mikronode.Channel.html#event:event:timeout">event:timeout</a></li>
            
                <li data-name="mikronode.Channel#event:trap"><a href="mikronode.Channel.html#event:event:trap">event:trap</a></li>
            
            </ul>
        </li>
    
        <li class="item" data-name="mikronode.Connection">
            <span class="title">
                <a href="mikronode.Connection.html">mikronode.Connection</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="mikronode.Connection#closeOnDone"><a href="mikronode.Connection.html#closeOnDone">closeOnDone</a></li>
            
                <li data-name="mikronode.Connection#host"><a href="mikronode.Connection.html#host">host</a></li>
            
                <li data-name="mikronode.Connection#password"><a href="mikronode.Connection.html#password">password</a></li>
            
                <li data-name="mikronode.Connection#port"><a href="mikronode.Connection.html#port">port</a></li>
            
                <li data-name="mikronode.Connection#status"><a href="mikronode.Connection.html#status">status</a></li>
            
                <li data-name="mikronode.Connection#timeout"><a href="mikronode.Connection.html#timeout">timeout</a></li>
            
                <li data-name="mikronode.Connection#user"><a href="mikronode.Connection.html#user">user</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            <span class="subtitle">Typedefs</span>
            
                <li data-name="mikronode.Connection.connectCallback"><a href="mikronode.Connection.html#.connectCallback">connectCallback</a></li>
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="mikronode.Connection#closeChannel"><a href="mikronode.Connection.html#closeChannel">closeChannel</a></li>
            
                <li data-name="mikronode.Connection#connect"><a href="mikronode.Connection.html#connect">connect</a></li>
            
                <li data-name="mikronode.Connection#getChannel"><a href="mikronode.Connection.html#getChannel">getChannel</a></li>
            
                <li data-name="mikronode.Connection#getCommandPromise"><a href="mikronode.Connection.html#getCommandPromise">getCommandPromise</a></li>
            
                <li data-name="mikronode.Connection#getConnectPromise"><a href="mikronode.Connection.html#getConnectPromise">getConnectPromise</a></li>
            
                <li data-name="mikronode.Connection#openChannel"><a href="mikronode.Connection.html#openChannel">openChannel</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            <span class="subtitle">Events</span>
            
                <li data-name="mikronode.Connection#event:close"><a href="mikronode.Connection.html#event:event:close">event:close</a></li>
            
                <li data-name="mikronode.Connection#event:error"><a href="mikronode.Connection.html#event:event:error">event:error</a></li>
            
                <li data-name="mikronode.Connection#event:timeout"><a href="mikronode.Connection.html#event:event:timeout">event:timeout</a></li>
            
                <li data-name="mikronode.Connection#event:trap"><a href="mikronode.Connection.html#event:event:trap">event:trap</a></li>
            
            </ul>
        </li>
    
        <li class="item" data-name="mikronode.MikroNode">
            <span class="title">
                <a href="mikronode.MikroNode.html">mikronode.MikroNode</a>
                
            </span>
            <ul class="members itemMembers">
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            <span class="subtitle">Methods</span>
            
                <li data-name="mikronode.MikroNode.getConnection"><a href="mikronode.MikroNode.html#.getConnection">getConnection</a></li>
            
                <li data-name="mikronode.MikroNode.parseItems"><a href="mikronode.MikroNode.html#.parseItems">parseItems</a></li>
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
        <li class="item" data-name="mikronode.Trap">
            <span class="title">
                <a href="mikronode.Trap.html">mikronode.Trap</a>
                
            </span>
            <ul class="members itemMembers">
            
            <span class="subtitle">Members</span>
            
                <li data-name="mikronode.Trap#category"><a href="mikronode.Trap.html#category">category</a></li>
            
                <li data-name="mikronode.Trap#channel"><a href="mikronode.Trap.html#channel">channel</a></li>
            
                <li data-name="mikronode.Trap#channelId"><a href="mikronode.Trap.html#channelId">channelId</a></li>
            
                <li data-name="mikronode.Trap#message"><a href="mikronode.Trap.html#message">message</a></li>
            
            </ul>
            <ul class="typedefs itemMembers">
            
            </ul>
            <ul class="methods itemMembers">
            
            </ul>
            <ul class="events itemMembers">
            
            </ul>
        </li>
    
    </ul>
</div>
    <div class="main">
        <h1 class="page-title" data-filename="index.html">Index</h1>
        


    


    <h3> </h3>








    




    <section>
        <article class="readme"><h1>Mikronode</h1><p>  Full-Featured asynchronous Mikrotik API interface for <a href="http://nodejs.org">NodeJS</a>.</p>
<pre class="prettyprint source"><code>    var MikroNode = require('../lib/index.js');

    var connection = MikroNode.getConnection(process.argv[2], process.argv[3], process.argv[4]);
    connection.connect(function(conn) {

    var chan = conn.openChannel();
    conn.closeOnDone = true;
    chan.write('/ip/address/print', function() {
        chan.closeOnDone = true;
        chan.on('done', function(data) {
            var parsed = MikroNode.parseItems(data);
            parsed.forEach(function(item) {
                console.log('Interface/IP: ' + item.interface + &quot;/&quot; + item.address);
            });
        });
        chan.once('trap', function(trap, chan) {
            console.log('Command failed: ' + trap);
        });
        chan.once('error', function(err, chan) {
            console.log('Oops: ' + err);
        });
    });
});

/* Now let's do this with Promises */

var connection = MikroNode.getConnection(process.argv[2], process.argv[3], process.argv[4], {
    closeOnDone : true
});

connection.getConnectPromise().then(function(conn) {
    conn.getCommandPromise('/ip/address/print').then(function resolved(values) {
        console.log('Addreses: ' + JSON.stringify(values));
    }, function rejected(reason) {
        console.log('Oops: ' + JSON.stringify(reason));
    });
});</code></pre><h2>Installation</h2><p>  Clone this repository into your node_modules directory.</p>
<ul>
<li>or -<br> $ npm install mikronode</li>
</ul>
<h2>Features</h2><ul>
<li>Channel based communication</li>
<li>Multiple channels can be used at once.</li>
<li>Synchronous execution of commands issued on the same channel.</li>
<li>Asynchrounous execution of commands issued on different channels.</li>
<li>Focus on high performance</li>
<li>ES6 Promise support</li>
</ul>
<h2>TODO</h2><ul>
<li>Write tests con make sure everything keeps working while making above changes.</li>
</ul>
<h2>API</h2><pre class="prettyprint source"><code>[API JSDocs](dist/index.grml)</code></pre><h3>Connection</h3><p>  Calling new api(host,user,pass) returns a connection object.</p>
<ul>
<li>RouterBoard need the connection before execute any comm.</li>
<li>conn.connect(callback)<br>  Connect to the target device. The callback function is called after successful login with the current connection object as its parameter.</li>
<li>conn.openChannel(id)<br>  Open and return a new channel object. Each channel is a unique command line to the mikrotik, allowing simultaneous execution of commands. The ID parameter is optional.</li>
<li>conn.connected()<br>  Returns true is currently connected to a mikrotik device.</li>
<li>conn.closeChannel(id)<br>  Closes an open channel. This will call the close method of the channel object.</li>
<li>conn closeOnDone(b)<br>  If b == true, when a done event occurs, close the connection after all channels have been closed.</li>
<li>conn.close(force)<br>  Close the connection. If force is true, force close of any open channels then close this connection.</li>
<li>conn.getHost()</li>
<li>conn.getUser()</li>
</ul>
<h3>Channel</h3><p>  The following methods are available for channels:</p>
<ul>
<li>channel.closeOnDone(b)<br>  If b == true, when a done event occurs, close the channel after all commands queued have been executed.</li>
<li>channel.saveBuffer(b)<br>  If b is true, then save each line received in a buffer and pass the entire buffer to the done event. Otherwise the done event will not get all the lines, only the last line.<br>  This is handy when following trailing output from a listen command, where the data could be endless.</li>
<li>channel.getConnection()</li>
<li>channel.getId()</li>
<li>channel.write(lines,writeCallback)<br>  Lines can be a string, or an array of strings. If it is a string, then it is split on the EOL character and each resulting line is sent as a separate word (in API speak)<br>  If lines is an array, then each element is sent unaltered.</li>
<li>channel.close(force)<br>  Close the channel. If there are any commands still waiting to be executed, they will be completed before closing the channel.<br>  If force is TRUE, then the channel is immediately closed. If the channel is running, the cancel command is sent to stop any running listen commands, or potentially long running output.</li>
</ul>
<h2>Examples</h2><h3>Connect to a Mikrotik, and add an address to ether1</h3><pre class="prettyprint source"><code> var api = require('mikronode');

 var connection = new api('192.168.0.1','admin','password');
 connection.connect(function(conn) {

    var chan=conn.openChannel();

    chan.write(['/ip/address/add','=interface=ether1','=address=192.168.1.1'],function() {
       chan.on('trap',function(data) {
          console.log('Error setting IP: '+data);
       });
       chan.on('done',function(data) {
          console.log('IP Set.');
       });
       chan.close();
       conn.close();
    });
 });</code></pre><h3>Writing the program for the example API conversation on the <a href="http://wiki.mikrotik.com/wiki/API#.2Fcancel.2C_simultaneous_commands">Mikrotik Wiki</a></h3><pre class="prettyprint source"><code> var api = require('mikronode');

 var connection = new api('192.168.0.1','admin','password');
 connection.connect(function(conn) {

    conn.closeOnDone(true);
    var chan2=conn.openChannel(2);
    chan2.write('/interface/listen',function(chan) {
       chan.on('read',function(data) {
          packet=api.parseItems([data])[0];
          console.log('Interface change: '+JSON.stringify(packet));
       });
    });

    var chan3=conn.openChannel(3);
    chan3.closeOnDone(true);

    chan3.write(['/interface/set','=disabled=yes','=.id=ether1'],function(chan) {
       chan.on('done',function(d,chan) {
          // We do this here, 'cause we want channel 4 to write after channel 3 is done.
          var chan4=conn.openChannel(4); // We'll use this later.
          chan4.closeOnDone(true);
          chan4.write(['/interface/set','=disabled=no','=.id=ether1'],function() {
            var chan5=conn.openChannel(5); 
            chan5.closeOnDone(true);
            chan5.write('/interface/getall',function(chan) {
               chan.on('done',function(data) {
                  packets=api.parseItems(data);
                  packets.forEach(function(packet) {
                      console.log('Interface: '+JSON.stringify(packet));
                  });
                  chan2.close(); // This should call the /cancel command to stop the listen.
               });
            });
          })
       });
    });
 });</code></pre><h3>Simplifying the above by reducing the number of channels.</h3><p>  Notice how the callback embedding is not needed using the syncronous capability.</p>
<pre class="prettyprint source"><code> var api = require('mikronode');

 var connection = new api('192.168.0.1','admin','password');
 connection.connect(function(conn) {

    conn.closeOnDone(true); // All channels need to complete before the connection will close.
    var listenChannel=conn.openChannel();
    listenChannel.write('/interface/listen',function(chan) {
       chan.on('read',function(data) {
          packet=api.parseItems([data])[0];
          console.log('Interface change: '+JSON.stringify(packet));
       });
    });

    var actionChannel=conn.openChannel();
    // These will run synchronsously
    actionChannel.write(['/interface/set','=disabled=yes','=.id=ether1']); // don't care to do anything after it's done.
    actionChannel.write(['/interface/set','=disabled=no','=.id=ether1']); // don't care to do anything after it's done.
    actionChannel.write('/interface/getall',function(chan) {
       chan.on('done',function(data) {
          packets=api.parseItems(data);
          packets.forEach(function(packet) {
              console.log('Interface: '+JSON.stringify(packet));
          });
          listenChannel.close(); // This should call the /cancel command to stop the listen.
       });
    });
    actionChannel.close(); // The above commands will complete before this is closed.
 });</code></pre><p>  The method <em>decodeLength</em> and <em>encodeString</em> were written based on code <a href="http://wiki.mikrotik.com/wiki/API_PHP_class#Class">here on the Mikrotik Wiki</a>.</p>
<h2>License</h2><p>(The MIT License)</p>
<p>Copyright (c) 2011 Brandon Myers <a href="&#x6d;&#x61;&#105;&#x6c;&#116;&#111;&#x3a;&#116;&#x72;&#x61;&#107;&#107;&#x61;&#x73;&#x75;&#114;&#x65;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;">&#116;&#x72;&#x61;&#107;&#107;&#x61;&#x73;&#x75;&#114;&#x65;&#x40;&#103;&#109;&#97;&#x69;&#x6c;&#x2e;&#99;&#x6f;&#x6d;</a></p>
<p>Permission is hereby granted, free of charge, to any person obtaining<br>a copy of this software and associated documentation files (the<br>'Software'), to deal in the Software without restriction, including<br>without limitation the rights to use, copy, modify, merge, publish,<br>distribute, sublicense, and/or sell copies of the Software, and to<br>permit persons to whom the Software is furnished to do so, subject to<br>the following conditions:</p>
<p>The above copyright notice and this permission notice shall be<br>included in all copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,<br>EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF<br>MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.<br>IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY<br>CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,<br>TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE<br>SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p></article>
    </section>






        

        <footer>
            Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Sun Dec 20 2015 18:31:54 GMT-0700 (MST)
        </footer>
    </div>
</div>
<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
<script src="scripts/main.js"></script>
</body>
</html>